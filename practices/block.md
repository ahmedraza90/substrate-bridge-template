âœ… 1. What is a Block Hash?
A block hash is a cryptographic fingerprint (like a unique ID) for a block.

It is generated by hashing the entire block header.

ğŸ“¦ A Block Header typically includes:
parent_hash â†’ the hash of the previous block

state_root â†’ the hash of the entire blockchain state at this block

extrinsics_root â†’ hash of all transactions (extrinsics) in the block

digest â†’ metadata like which consensus engine was used

... and more (like timestamp, block number, etc.)

ğŸ§¾ So the receiving chain (Rialto) receives:
âœ… BlockHeader â†’ summarized info about the block
âœ… FinalityProof â†’ proof that validators finalized that block

ğŸ“¬ In Short:
When Millau sends data to Rialto (through a relayer), it sends:

What	Purpose
ğŸ§¾ Block Header	Gives basic summary + hash link to previous block
ğŸ” Finality Proof	Cryptographic evidence that validators agreed this block is final
ğŸªª (Optional) Validator Set Info	Only if validator set changed and receiver needs to know



âœ… 1. Block Header (not the whole block!)
This includes:

markdown
Copy
Edit
BlockHeader {
    parent_hash,
    state_root,
    extrinsics_root,
    digest,
    number,
    ... maybe some other metadata
}
ğŸ‘‰ This is the part that gets hashed to create the block hash.

âœ… 2. Finality Proof
This is separate from the header, and it includes:

rust
Copy
Edit
FinalityProof {
    block_hash,                  // the hash of the block being finalized
    justification: GrandpaJustification {
        round_number,
        signatures: Vec<(ValidatorId, Signature)>,
        maybe_votes,
        maybe_set_id,
    }
}


Block hash inside the finality proof â›“ï¸ IS the same as the hash of the block header

Thereâ€™s no separate or special block hash inside the finality proof.
They are exactly the same thing â€” just used in different places.


The light client receives:

The block hash (e.g., hash of Block #100)

A list of validator signatures

Some metadata proving those signatures came from the currently active validator set

Then it:

Verifies that enough validators signed (usually 2/3).

Verifies each signature is correct (they really signed that block hash).

Verifies these validators are from the correct validator set.


ğŸ” 2. When Are Headers Sent Between Chains?
There are 2 styles of sending headers:

ğŸ”¹ (A) Periodically (automatic relaying):
Every time Millau creates a new block, it automatically sends its header to Rialto.

This is done by a relayer process â€” off-chain code that:

Watches Millau for new finalized blocks

Sends those headers (plus proofs) to Rialto

Keeps Rialtoâ€™s light client up to date

So Rialto can keep track of Millauâ€™s chain block-by-block.

ğŸ”¹ (B) On-demand (only when needed):
Maybe Rialto only needs to know about Millau when something happens, like:

A cross-chain token transfer

A specific event

In that case, a relayer sends the latest header and proof at that time.

Rialto might catch up from previous headers using a batch of them.


If headers are sent on-demand (not one-by-one), and the receiver suddenly gets a later block, how can it verify the parent_hash without having the previous blockâ€™s header?

Letâ€™s break this down super clearly.

ğŸ”¹ Option B: On-demand Header Sync
Letâ€™s say:

Rialto knows only up to block #90 of Millau.

Then, suddenly, a relayer sends block #100's header and its finality proof.

Now you're asking:

â“How can Rialto verify that block #100 is legit, if it doesn't have #91â€“#99?

âœ… Answer: It can't verify block #100 directly â€” it needs the missing headers.
So in Option B, the relayer must send not just block #100, but also:

A batch of headers from #91 to #100

OR a justification that skips blocks (if supported by the consensus)