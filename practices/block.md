✅ 1. What is a Block Hash?
A block hash is a cryptographic fingerprint (like a unique ID) for a block.

It is generated by hashing the entire block header.

📦 A Block Header typically includes:
parent_hash → the hash of the previous block

state_root → the hash of the entire blockchain state at this block

extrinsics_root → hash of all transactions (extrinsics) in the block

digest → metadata like which consensus engine was used

... and more (like timestamp, block number, etc.)

🧾 So the receiving chain (Rialto) receives:
✅ BlockHeader → summarized info about the block
✅ FinalityProof → proof that validators finalized that block

📬 In Short:
When Millau sends data to Rialto (through a relayer), it sends:

What	Purpose
🧾 Block Header	Gives basic summary + hash link to previous block
🔐 Finality Proof	Cryptographic evidence that validators agreed this block is final
🪪 (Optional) Validator Set Info	Only if validator set changed and receiver needs to know



✅ 1. Block Header (not the whole block!)
This includes:

markdown
Copy
Edit
BlockHeader {
    parent_hash,
    state_root,
    extrinsics_root,
    digest,
    number,
    ... maybe some other metadata
}
👉 This is the part that gets hashed to create the block hash.

✅ 2. Finality Proof
This is separate from the header, and it includes:

rust
Copy
Edit
FinalityProof {
    block_hash,                  // the hash of the block being finalized
    justification: GrandpaJustification {
        round_number,
        signatures: Vec<(ValidatorId, Signature)>,
        maybe_votes,
        maybe_set_id,
    }
}


Block hash inside the finality proof ⛓️ IS the same as the hash of the block header

There’s no separate or special block hash inside the finality proof.
They are exactly the same thing — just used in different places.


The light client receives:

The block hash (e.g., hash of Block #100)

A list of validator signatures

Some metadata proving those signatures came from the currently active validator set

Then it:

Verifies that enough validators signed (usually 2/3).

Verifies each signature is correct (they really signed that block hash).

Verifies these validators are from the correct validator set.


🔁 2. When Are Headers Sent Between Chains?
There are 2 styles of sending headers:

🔹 (A) Periodically (automatic relaying):
Every time Millau creates a new block, it automatically sends its header to Rialto.

This is done by a relayer process — off-chain code that:

Watches Millau for new finalized blocks

Sends those headers (plus proofs) to Rialto

Keeps Rialto’s light client up to date

So Rialto can keep track of Millau’s chain block-by-block.

🔹 (B) On-demand (only when needed):
Maybe Rialto only needs to know about Millau when something happens, like:

A cross-chain token transfer

A specific event

In that case, a relayer sends the latest header and proof at that time.

Rialto might catch up from previous headers using a batch of them.


If headers are sent on-demand (not one-by-one), and the receiver suddenly gets a later block, how can it verify the parent_hash without having the previous block’s header?

Let’s break this down super clearly.

🔹 Option B: On-demand Header Sync
Let’s say:

Rialto knows only up to block #90 of Millau.

Then, suddenly, a relayer sends block #100's header and its finality proof.

Now you're asking:

❓How can Rialto verify that block #100 is legit, if it doesn't have #91–#99?

✅ Answer: It can't verify block #100 directly — it needs the missing headers.
So in Option B, the relayer must send not just block #100, but also:

A batch of headers from #91 to #100

OR a justification that skips blocks (if supported by the consensus)